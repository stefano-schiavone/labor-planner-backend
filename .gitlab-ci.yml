# =========================================================
# GitLab CI/CD Pipeline for Spring Boot Application
# =========================================================
# I structured this pipeline to run fully on a VM with Docker.
# Each stage runs in an isolated container (industry best practice).
# H2 is used for tests, PostgreSQL for staging and integration.
# =========================================================

stages:
   - build # Compile the code and build JAR
   - test # Run unit/integration tests (H2 DB)
   - sonar # Run SonarQube tests
   - staging # Run staging environment (PostgreSQL DB)
   - package # Package artifacts for Docker image
   - image # Build & push Docker image
   - deploy-production # Deploy to staging server

# =========================================================
# Global Variables
# =========================================================
variables:
   SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
   # SONAR_HOST_URL: "http://sonarqube:9000"
   SONAR_HOST_URL: "http://192.168.120.4:9000"
   # SONAR_TOKEN: "squ_e674212a80e2b2df73bb77979fc1895ab5620ba0"
   # SONAR_TOKEN: "sqp_2620e1fac3f05e972c2d7507bbe247a2ccd50c5c"
   # SONAR_TOKEN: "sqa_197e411cdfaf7864b26146ecd774901221dd0613"
   GRADLE_OPTS: "-Dorg.gradle.daemon=false"
   # I keep Gradle cache inside the project so it can be cached by GitLab
   GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
   # Required for Docker-in-Docker
   DOCKER_TLS_CERTDIR: ""
   IMAGE_TAG: "$CI_COMMIT_REF_SLUG"
   DOCKER_PULL_POLICY: if-not-present # Only goes to Docker Hub if images aren't present
   DOCKER_AUTH_CONFIG: >
      {
        "auths": {
          "https://index.docker.io/v1/": {
            "username": "$CI_REGISTRY_USER",
            "password": "$CI_REGISTRY_PASSWORD"
          }
        }
      }

# =========================================================
# Cache Settings
# =========================================================
cache:
   key: "$CI_COMMIT_REF_SLUG" # Each branch gets its own cache
   paths:
      - .gradle/wrapper # Gradle wrapper cache
      - .gradle/caches # Gradle dependency cache

# =========================================================
# Before Script
# =========================================================
before_script:
   - export GRADLE_USER_HOME=$(pwd)/.gradle
   - chmod +x gradlew
   - docker info || true # Verify Docker is accessible (DinD)

# =========================================================
# Build Stage
# =========================================================
build:
   stage: build
   image: gradle:8.14.3-jdk21-jammy # I use Gradle + JDK image for build
   script:
      - ./gradlew clean build -x test # Build the JAR but skip tests (faster)
   artifacts:
      paths:
         - build/libs/*.jar # Save the JAR for later stages
      expire_in: 1 week
   cache:
      policy: pull-push
      paths:
         - .gradle/
   rules:
      - if: '$CI_PIPELINE_SOURCE == "merge_request_event"' # always run for MRs
        when: always
      - if: '$CI_COMMIT_BRANCH == "main"' # always run for main
        when: always
      - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"' # feature branch push
        when: on_success

# =========================================================
# Test Stage
# =========================================================
# I use H2 DB in memory because it's lightweight and fast
test:
   stage: test
   image: eclipse-temurin:21-jdk-jammy
   variables:
      SPRING_PROFILES_ACTIVE: test
   script:
      - ./gradlew test
   artifacts:
      when: always
      reports:
         junit: build/test-results/test/TEST-*.xml
   rules:
      - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
        when: always
      - if: '$CI_COMMIT_BRANCH == "main"'
        when: always
      - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
        when: always

# =========================================================
# Sonar Stage
# =========================================================
# ---- Modified Sonar job: do NOT start a sonarqube service here.
# We explicitly point to your reachable SonarQube server (SONAR_HOST_URL),
# validate token with curl, remove any generated resolver file and force
# Gradle to run in a fresh process (--no-daemon) using -Dsonar.token.
# sonar:
#   stage: sonar
#   image: gradle:8.14.3-jdk21-jammy
#   services:
#     - name: sonarqube:community
#       alias: sonarqube
#   variables:
#     SONAR_HOST_URL: "$SONAR_HOST_URL"
#   script:
#     - set -eo pipefail
#     - echo "Running SonarQube analysis against $SONAR_HOST_URL"
#     - chmod +x gradlew
#     # Validate the token available to CI before invoking Gradle.
#     - |
#       if [ -z "$SONAR_TOKEN" ]; then
#         echo "ERROR: SONAR_TOKEN is not set in CI variables. Add it in Settings → CI/CD → Variables."
#         exit 1
#       fi
#     - echo "Validating SONAR_TOKEN against Sonar API..."
#     - if ! curl -s -u "${SONAR_TOKEN}:" "$SONAR_HOST_URL/api/v2/analysis/version" >/dev/null 2>&1; then
#         echo "SONAR_TOKEN validation failed for $SONAR_HOST_URL (HTTP 401). Ensure the token is correct and available to this pipeline.";
#         exit 1;
#       fi
#     # Remove resolver/properties if created previously to avoid stale sonar.token values
#     - rm -f build/sonar-resolver/properties || true
#     - rm -rf .sonar || true
#     # Build artifact in a fresh Gradle process (no daemon to avoid inherited env/properties)
#     - ./gradlew --no-daemon clean build -x test
#     # Force Gradle to use the explicit token passed as system property.
#     - |
#       echo "Invoking Gradle sonar with explicit -Dsonar.token (using --no-daemon)..."
#       ./gradlew --no-daemon -Dsonar.host.url="$SONAR_HOST_URL" -Dsonar.token="$SONAR_TOKEN" sonar --info
#   rules:
#     - if: '$CI_COMMIT_BRANCH == "main"'
#       when: always
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
#       when: always
#     - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
#       when: always
#
sonar:
  stage: sonar
  image: gradle:8.14.3-jdk21-jammy
  services:
    - name: sonarqube:community
      alias: sonarqube
  variables:
    SONAR_HOST_URL: "http://sonarqube:9000"
    SONAR_WAIT_TIMEOUT: "240"
    SONAR_WAIT_INTERVAL: "5"
  before_script:
    - chmod +x gradlew
    - |
      echo "Waiting for Sonar (service alias 'sonarqube') at $SONAR_HOST_URL..."
      END=$((SECONDS + ${SONAR_WAIT_TIMEOUT:-240}))
      while [ $SECONDS -lt $END ]; do
        if curl -sSf "$SONAR_HOST_URL/api/server/version" >/dev/null 2>&1; then
          echo "Sonar is up"
          break
        fi
        echo "Sonar not ready yet, sleeping ${SONAR_WAIT_INTERVAL:-5}s..."
        sleep ${SONAR_WAIT_INTERVAL:-5}
      done
      if ! curl -sSf "$SONAR_HOST_URL/api/server/version" >/dev/null 2>&1; then
        echo "ERROR: Sonar did not become ready within ${SONAR_WAIT_TIMEOUT}s"
        exit 1
      fi
  script:
    - set -eo pipefail
    - echo "Preparing Sonar analysis against $SONAR_HOST_URL (won't print tokens)"
    # validate existing token (if provided) or generate one with admin:admin for the in-job Sonar
    - |
      GENERATED_TOKEN_NAME=""
      GENERATED=0
      validate_token() {
        curl -s -u "${1}:" "$SONAR_HOST_URL/api/v2/analysis/version" >/dev/null 2>&1
      }
      if [ -n "$SONAR_TOKEN" ] && validate_token "$SONAR_TOKEN"; then
        echo "SONAR_TOKEN provided to the job is valid for $SONAR_HOST_URL"
      else
        echo "SONAR_TOKEN missing or invalid for $SONAR_HOST_URL — generating temporary token via admin:admin"
        GENERATED_TOKEN_NAME="gitlab-ci-${CI_PIPELINE_ID:-manual}-${CI_JOB_ID:-0}"
        # create token (response contains JSON with "token":"..."), don't print it
        resp=$(curl -s -u admin:Stefano.Schiavone32 -X POST "$SONAR_HOST_URL/api/user_tokens/generate?name=$GENERATED_TOKEN_NAME")
        token=$(echo "$resp" | sed -n 's/.*"token":"\([^"]*\)".*/\1/p')
        if [ -z "$token" ]; then
          echo "Failed to generate token. Sonar response:"
          echo "$resp"
          echo "If your Sonar instance does not use default admin:admin credentials, create a token manually and add it to GitLab CI variables as SONAR_TOKEN."
          exit 1
        fi
        export SONAR_TOKEN="$token"
        GENERATED=1
        echo "Temporary SONAR token generated for this job (will be revoked after scan)."
      fi
    - echo "Removing stale sonar resolver files if present..."
    - rm -f build/sonar-resolver/properties || true
    - rm -rf .sonar || true
    - echo "Building artifact (no daemon) to ensure fresh Gradle JVM..."
    - ./gradlew --no-daemon clean build -x test
    - echo "Invoking Gradle sonar (no daemon) with explicit -Dsonar.token (token hidden)..."
    - ./gradlew --no-daemon -Dsonar.host.url="$SONAR_HOST_URL" -Dsonar.token="$SONAR_TOKEN" sonar --info
    - |
      if [ "$GENERATED" = "1" ]; then
        echo "Revoking temporary token $GENERATED_TOKEN_NAME..."
        # revoke token created earlier; ignore failure but attempt revoke
        curl -s -u admin:admin -X POST "$SONAR_HOST_URL/api/user_tokens/revoke?name=$GENERATED_TOKEN_NAME" >/dev/null || true
        echo "Revocation attempted."
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
      when: always

# =========================================================
# Staging Stage
# =========================================================
# I want this stage to run in its own container with PostgreSQL
# Each staging container is isolated from other stages (industry best practice)
staging:
   stage: staging
   image: gradle:8.14.3-jdk21-jammy
   services:
      - name: postgres:15.14-alpine3.22
        alias: postgres-staging
        variables:
           POSTGRES_DB: stagingdb
           POSTGRES_USER: staging
           POSTGRES_PASSWORD: staging
           POSTGRES_HOST_AUTH_METHOD: scram-sha-256
   variables:
      SPRING_PROFILES_ACTIVE: staging
      DB_HOST: postgres-staging
      DB_PORT: 5432
      POSTGRES_DB: stagingdb
      POSTGRES_USER: staging
      POSTGRES_PASSWORD: staging
   script:
      - ./gradlew bootRun &
      - APP_PID=$!
      - echo "Waiting 15 seconds to ensure app connects to PostgreSQL..."
      - sleep 15
      - echo "Stopping app process"
      - kill $APP_PID
   rules:
      - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
        when: always # only on MRs

# =========================================================
# Package Stage
# =========================================================
package:
   stage: package
   needs: ["build"]
   script:
      - echo "Artifacts already built in build stage"
   dependencies:
      - build
   artifacts:
      paths:
         - build/libs/*.jar
      expire_in: 1 week
   rules:
      - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
        when: always
      - if: '$CI_COMMIT_BRANCH == "main"'
        when: always
      - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
        when: on_success

# =========================================================
# Docker Image Stage
# =========================================================
docker-build-push:
   stage: image
   image: docker:24.0.2
   services:
      - name: docker:24.0.2-dind
        command: ["--insecure-registry=192.168.120.4:5000"]
   variables:
      DOCKER_HOST: tcp://docker:2375 # <-- Force the job container talk to DinD
      DOCKER_TLS_CERTDIR: "" # <-- Disable TLS inside DinD
      PRIVATE_REGISTRY: "$STAGING_SSH_HOST:5000"
      IMAGE: "$PRIVATE_REGISTRY/labor-planner-backend:$IMAGE_TAG"
   needs:
      - job: package
        artifacts: true
   script:
      - echo "Building Docker image for private registry:"
      - docker build -t "$IMAGE" .
      - docker push "$IMAGE"
      - echo "Pushing to private registry..."
      - echo $IMAGE
      - echo "----------------------"
   artifacts:
      expire_in: 1 week
   rules:
      - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
        when: always
      - if: '$CI_COMMIT_BRANCH == "main"'
        when: always
      - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
        when: always

# =========================================================
# Deploy to Production Server
# =========================================================
# This connects via SSH and runs the latest Docker image
deploy-production:
   stage:
      deploy-production
   image:
      alpine:latest
   before_script:
      - apk add --no-cache openssh-client bash
      - mkdir -p ~/.ssh
      - echo "$PROD_KNOWN_HOSTS" > ~/.ssh/known_hosts
      - echo "$PROD_SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_ed25519
      - chmod 600 ~/.ssh/id_ed25519
    # This way of writing the command is used because it needs to support multi lines and otherwise the env variables give problems
   script:
    - |
      ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes $PROD_SSH_USER@$PROD_SSH_HOST \
        "docker pull $PROD_SSH_HOST:5000/labor-planner-backend:$IMAGE_TAG && \
         if docker ps -a --filter 'name=app-prod' --format '{{.ID}}' | grep -q .; then \
           docker stop app-prod && docker rm -f app-prod; \
         fi && \
         docker run -d --name app-prod -p 8080:8080 \
           --env SPRING_PROFILES_ACTIVE=prod \
           --env PROD_DB_URL='$PROD_DB_URL' \
           --env PROD_DB_USER='$PROD_DB_USER' \
           --env PROD_DB_PASSWORD='$PROD_DB_PASSWORD' \
           $PROD_SSH_HOST:5000/labor-planner-backend:$IMAGE_TAG"
   environment:
      name: production
      url: "http://$PROD_SSH_HOST:8080"
   rules:
      - if: '$CI_COMMIT_BRANCH == "main"'
   when: manual # manual trigger only on main
