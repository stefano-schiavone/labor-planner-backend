# =========================================================
# GitLab CI/CD Pipeline for Spring Boot Application
# =========================================================
# I structured this pipeline to run fully on a VM with Docker.
# Each stage runs in an isolated container (industry best practice).
# H2 is used for tests, PostgreSQL for staging and integration.
# =========================================================

stages:
  - build        # Compile the code and build JAR
  - test         # Run unit/integration tests (H2 DB)
  - staging      # Run staging environment (PostgreSQL DB)
  - package      # Package artifacts for Docker image
  - image        # Build & push Docker image
  - deploy-staging # Deploy to staging server

# =========================================================
# Global Variables
# =========================================================
variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  # I keep Gradle cache inside the project so it can be cached by GitLab
  GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
  # Required for Docker-in-Docker
  DOCKER_TLS_CERTDIR: ""
  IMAGE_TAG: "$CI_COMMIT_REF_SLUG"

# =========================================================
# Cache Settings
# =========================================================
cache:
  key: "$CI_COMMIT_REF_SLUG"  # Each branch gets its own cache
  paths:
    - .gradle/wrapper          # Gradle wrapper cache
    - .gradle/caches           # Gradle dependency cache

# =========================================================
# Before Script
# =========================================================
before_script:
  - export GRADLE_USER_HOME=$(pwd)/.gradle
  - chmod +x gradlew
  - docker info || true  # Verify Docker is accessible (DinD)

# =========================================================
# Build Stage
# =========================================================
build:
  stage: build
  image: gradle:8.14.3-jdk21-jammy   # I use Gradle + JDK image for build
  script:
    - ./gradlew clean build -x test  # Build the JAR but skip tests (faster)
  artifacts:
    paths:
      - build/libs/*.jar   # Save the JAR for later stages
    expire_in: 1 week
  cache:
    policy: pull-push
    paths:
      - .gradle/
  rules:
    # I wanted fast feedback before I make a merge request 
    # run on every branch push (except main)
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
      when: always
    # run on merge request events
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always
    # also run on main branch
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always

# =========================================================
# Test Stage
# =========================================================
# I use H2 DB in memory because it's lightweight and fast
test:
  stage: test
  image: eclipse-temurin:21-jdk-jammy
  services:
    - name: postgres:15-alpine
      aalias: db
      variables:
        POSTGRES_DB: testdb
        POSTGRES_USER: test
        POSTGRES_PASSWORD: test
  variables:
    SPRING_PROFILES_ACTIVE: test
  script:
    - ./gradlew test
  artifacts:
    when: always
    reports:
      junit: build/test-results/test/TEST-*.xml
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH'

# =========================================================
# Staging Stage
# =========================================================
# I want this stage to run in its own container with PostgreSQL
# Each staging container is isolated from other stages (industry best practice)
staging:
  stage: staging
  image: openjdk:21-jdk-jammy
  services:
    - name: postgres:15-alpine
      alias: postgres-staging
      variables:
        POSTGRES_DB: stagingdb
        POSTGRES_USER: staging
        POSTGRES_PASSWORD: staging
  variables:
    SPRING_PROFILES_ACTIVE: staging
    POSTGRES_DB: stagingdb
    POSTGRES_USER: staging
    POSTGRES_PASSWORD: staging
    DB_HOST: postgres-staging
    DB_PORT: 5432
  script:
    - ./gradlew bootRun &
    - APP_PID=$!
    - echo "Waiting 15 seconds to ensure app connects to PostgreSQL..."
    - sleep 15
    - echo "Stopping app process"
    - kill $APP_PID
  when: manual
  allow_failure: true

# =========================================================
# Package Stage
# =========================================================
package:
  stage: package
  needs: ["build"]
  script:
    - echo "Artifacts already built in build stage"
  dependencies:
    - build
  artifacts:
    paths:
      - build/libs/*.jar
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH'

# =========================================================
# Docker Image Stage
# =========================================================
docker-build-push:
  stage: image
  image: docker:24.0.2
  services:
    - name: docker:24.0.2-dind
  variables:
    IMAGE: "$CI_REGISTRY_IMAGE:$IMAGE_TAG"
  needs:
    - job: package
      artifacts: true
  script:
    - echo "Logging into GitLab registry"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - export IMAGE="$(echo "$CI_REGISTRY_IMAGE" | tr '[:upper:]' '[:lower:]'):$IMAGE_TAG"
    - echo "Building Docker image: $IMAGE"
    - docker build -t "$IMAGE" .
    - docker push "$IMAGE"
    - echo "Docker image pushed: $IMAGE"
  artifacts:
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main"'
      when: manual

# =========================================================
# Deploy to Staging Server
# =========================================================
# This connects via SSH and runs the latest Docker image
deploy-staging:
  stage: deploy-staging
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client bash
  script:
    - mkdir -p ~/.ssh
    - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts || true
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh -o StrictHostKeyChecking=yes $STAGING_SSH_USER@$STAGING_SSH_HOST "
        docker login -u '$CI_REGISTRY_USER' -p '$CI_REGISTRY_PASSWORD' $CI_REGISTRY &&
        docker pull $CI_REGISTRY_IMAGE:$IMAGE_TAG &&
        docker ps -a --filter 'name=app-staging' --format '{{.ID}}' | grep -q . && docker stop app-staging || true &&
        docker rm -f app-staging || true &&
        docker run -d --name app-staging -p 8089:8080 --env SPRING_PROFILES_ACTIVE=staging $CI_REGISTRY_IMAGE:$IMAGE_TAG"
  environment:
    name: staging
    url: "http://$STAGING_SSH_HOST:8089"
  when: manual
  only:
    - main
